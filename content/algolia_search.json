[








{
"title": "Committers",
"tags": "",
"keywords": "",
"url": "../docs/committers",
"summary": "",
"body": "# Commit ActivityTo see commit activity for Quarks, click [here](https://github.com/apache/incubator-quarks/pulse).# How to Become a CommitterYou can become a committer by contributing to Quarks. Qualifications for a new committer include:* **Sustained Contributions**: Potential committers should have a history of contributions to Quarks. They will create pull requests over a period of time.  * **Quality of Contributions**: Potential committers should submit code that adds value to Quarks, including tests and documentation as needed. They should comment in a positive way on issues and pull requests, providing guidance and input to improve Quarks.* **Community Involvement**: Committers should participate in discussions in a positive way, triage and fix bugs, and interact with users who submit questions. They will remain courteous, and helpful, and encourage new members to join the Quarks community."

},




{
"title": "Common Quarks Operations",
"tags": "",
"keywords": "",
"url": "../docs/common-quarks-operations",
"summary": "",
"body": "# Common Quarks OperationsIn the first [getting started guide](quarks-getting-started), we covered a \"hello world\" Quarks application where we read from a device's simulated temperature sensor. Yet Quarks supports more operations than simple filtering. Data analysis and streaming require a suite of functionality, the most important components of which will be outlined below.## TStream.map()TStream.map() is arguably the most used method in the Quarks API. Its two main purposes are to perform stateful or stateless operations on a stream's tuples, and to produce a TStream with tuples of a different type from that of the calling stream.#### Changing a TStream's Tuple TypeIn addition to filtering tuples, TStreams support operations that *transform* tuples from one Java type to another by invoking the TStream.map() method.This is useful in cases such as calculating the floating point average of a list of Integers, or tokenizing a Java String into a list of Strings. To demonstrate this, let's say we have a TStream which contains a few lines, each of which contains multiple words:```java    TStream lines = topology.strings(            \"this is a line\",            \"this is another line\",            \"there are three lines now\",            \"and now four\"        );```We then want to print the third word in each line. The best way to do this is to convert each line to a list of Strings by tokenizing them. We can do this in one line of code with the TStream.map() method:```java    TStream > wordsInLine = lines.map(tuple -> Arrays.asList(tuple.split(\" \")));```Since each tuple is now a list of strings, the *wordsInLine* stream is of type List. As you can see, the map() method has the ability to change the type of the TStream. Finally, we can use the *wordsInLine* stream to print the third word in each line.```java    wordsInLine.sink(list -> System.out.println(list.get(2)));```As mentioned in the [getting started guide](quarks-getting-started), a TStream can be parameterized to any serializable Java type, including ones created by the user.#### Performing Stateful OperationsIn all previous examples, the operations performed on a TStream have been stateless; keeping track of information over multiple invocations of the same operation has not been necessary. What if we want to keep track of the number of Strings sent over a stream? To do this, we need our TStream.map() method to contain a counter as state.This can be achieved by creating an anonymous Function class, and giving it the required fields.```java    TStream streamOfStrings = ...;    TStream counts = streamOfStrings.map(new Function(){            int count = 0;            @Override            public Integer apply(String arg0) {                count = count + 1;                return count;            }        });```The *count* field will now contain the number of Strings which were sent over streamOfStrings. Although this is a simple example, the anonymous Function passed to TStream.map() can contain any kind of state! This could be a HashMap, a running list of tuples, or any serializable Java type. The state will be maintained throughout the entire runtime of your application."

},




{
"title": "Apache Quarks Community",
"tags": "",
"keywords": "",
"url": "../docs/community",
"summary": "",
"body": "Every volunteer project obtains its strength from the people involved in it. We invite you to participate as much or as little as you choose.You can:* Use our project and provide a feedback.* Provide us with the use-cases.* Report bugs and submit patches.* Contribute code, javadocs, documentation.Visit the [Contributing](http://www.apache.org/foundation/getinvolved.html) page and read [DEVELOPMENT.md] (https://github.com/apache/incubator-quarks/blob/master/DEVELOPMENT.md) at the top of the code tree for more information.### Mailing listGet help using {{ site.data.project.short_name }} or contribute to the project on our mailing lists:{% if site.data.project.user_list %}* [site.data.project.user_list](mailto:{{ site.data.project.user_list }}) is for usage questions, help, and announcements. [subscribe](mailto:{{ site.data.project.user_list_subscribe }}?subject=send this email to subscribe),     [unsubscribe](mailto:{{ site.data.project.dev_list_unsubscribe }}?subject=send this email to unsubscribe), [archives]({{ site.data.project.user_list_archive_mailarchive }}){% endif %}* [{{ site.data.project.dev_list }}](mailto:{{ site.data.project.dev_list }}) is for people who want to contribute code to {{ site.data.project.short_name }}. [subscribe](mailto:{{ site.data.project.dev_list_subscribe }}?subject=send this email to subscribe), [unsubscribe](mailto:{{ site.data.project.dev_list_unsubscribe }}?subject=send this email to unsubscribe), [archives]({{ site.data.project.dev_list_archive_mailarchive }})* [{{ site.data.project.commits_list }}](mailto:{{ site.data.project.commits_list }}) is for commit messages and patches to {{ site.data.project.short_name }}. [subscribe](mailto:{{ site.data.project.commits_list_subscribe }}?subject=send this email to subscribe), [unsubscribe](mailto:{{ site.data.project.commits_list_unsubscribe }}?subject=send this email to unsubscribe), [archives]({{ site.data.project.commits_list_archive_mailarchive }})### Issue trackerWe use Jira here: [https://issues.apache.org/jira/browse/QUARKS](https://issues.apache.org/jira/browse/QUARKS)#### Bug ReportsFound bug? Enter an issue in the [Issue Tracker](https://issues.apache.org/jira/browse/{{ site.data.project.jira }}).Before submitting an issue, please:* Verify that the bug does in fact exist.* Search the issue tracker to verify there is no existing issue reporting the bug you've found.* Consider tracking down the bug yourself in the {{ site.data.project.short_name }} source and submitting apull request  along with your bug report. This is a great time saver for the  {{ site.data.project.short_name }} developers and helps ensure the bug will be fixed quickly.#### Feature RequestsEnhancement requests for new features are also welcome. The more concrete and rationale the request is, the greater the chance it will incorporated into future releases.  [https://issues.apache.org/jira/browse/{{ site.data.project.jira }}](https://issues.apache.org/jira/browse/{{ site.data.project.jira }})### Source CodeThe project sources are accessible via the [source code repository]({{ site.data.project.source_repository }}) which is also mirrored in [GitHub]({{ site.data.project.source_repository_mirror }})### Website Source CodeThe project website sources are accessible via the [website source code repository]({{ site.data.project.website_repository }}) which is also mirrored in [GitHub]({{ site.data.project.website_repository_mirror }})"

},




{
"title": "Application Console",
"tags": "",
"keywords": "",
"url": "../docs/console",
"summary": "",
"body": "## Visualizing and monitoring your applicationThe Quarks application console is a web application that enables you to visualize your application topology and monitor the tuples flowing through your application.  The kind of oplets used in the topology, as well as the stream tags included in the topology, are also visible in the console.## Adding the console web app to your applicationTo use the console, you must use the Quarks classes that provide the service to access the console web application or directly call the `HttpServer` class itself, start the server and then obtain the console URL.The easiest way to include the console in your application is to use the the `DevelopmentProvider` class. `DevelopmentProvider` is a subclass of `DirectProvider` and adds services such as access to the console web application and counter oplets used to determine tuple counts. You can get the URL for the console from the `DevelopmentProvider` using the `getService` method as shown in a hypothetical application shown below:```    import java.util.concurrent.TimeUnit;    import quarks.console.server.HttpServer;    import quarks.providers.development.DevelopmentProvider;    import quarks.topology.TStream;    import quarks.topology.Topology;    public class TempSensorApplication {        public static void main(String[] args) throws Exception {            TempSensor sensor = new TempSensor();            DevelopmentProvider dp = new DevelopmentProvider();            Topology topology = dp.newTopology();            TStream tempReadings = topology.poll(sensor, 1, TimeUnit.MILLISECONDS);            TStream filteredReadings = tempReadings.filter(reading -> reading  80);            filteredReadings.print();            System.out.println(dp.getServices().getService(HttpServer.class).getConsoleUrl());            dp.submit(topology);          }    }```Note that the console URL is being printed to System.out. The filteredReadings are as well, since filteredReadings.print() is being called in the application.  You may need to scroll your terminal window up to see the output for the console URL.Optionally, you can modify the above code in the application to have a timeout before submitting the topology, which would allow you to see the console URL before any other output is shown.  The modification would look like this:```// print the console URL and wait for 10 seconds before submitting the topologySystem.out.println(dp.getServices().getService(HttpServer.class).getConsoleUrl());try {  TimeUnit.SECONDS.sleep(10);} catch (InterruptedException e) {  //do nothing}dp.submit(topology);```The other way to embed the console in your application is shown in the `HttpServerSample.java` example. It gets the HttpServer instance, starts it, and prints out the console URL.  Note that it does not submit a job, so when the console is displayed in the browser, there are no running jobs and therefore no Topology graph.  The example is meant to show how to get the `HttpServer` instance, start the console web app and get the URL of the console.# Accessing the consoleThe console URL has the following format:http://host_name:port_number/consoleOnce it is obtained from `System.out`, enter it in a browser window.  If you cannot access the console at this URL, ensure there is a `console.war` file in the `webapps` directory.  If the `console.war` file cannot be found, an exception will be thrown (in std.out) indicating `console.war` was not found.## ConsoleWaterDetector sampleTo see the features of the console in action and as a way to demonstrate how to monitor a topology in the console, let's look at the `ConsoleWaterDetector` sample.Prior to running any console applications, the `console.war` file must be built as mentioned above.  If you are building quarks from a Git repository, go to the top level Quarks directory and run `ant`.Here is an example in my environment:```Susans-MacBook-Pro-247:quarks susancline$ pwd/Users/susancline/git/quarksSusans-MacBook-Pro-247:quarks susancline$ antBuildfile: /Users/susancline/git/quarks/build.xmlsetcommitversion:init:suball:init:project.component:compile:...[javadoc] Constructing Javadoc information...[javadoc] Standard Doclet version 1.8.0_71[javadoc] Building tree for all the packages and classes...[javadoc] Generating /Users/susancline/git/quarks/target/docs/javadoc/quarks/analytics/sensors/package-summary.html...[javadoc] Copying file /Users/susancline/git/quarks/analytics/sensors/src/main/java/quarks/analytics/sensors/doc-files/deadband.png to directory /Users/susancline/git/quarks/target/docs/javadoc/quarks/analytics/sensors/doc-files...[javadoc] Generating /Users/susancline/git/quarks/target/docs/javadoc/quarks/topology/package-summary.html...[javadoc] Copying file /Users/susancline/git/quarks/api/topology/src/main/java/quarks/topology/doc-files/sources.html to directory /Users/susancline/git/quarks/target/docs/javadoc/quarks/topology/doc-files...[javadoc] Building index for all the packages and classes...[javadoc] Building index for all classes...all:BUILD SUCCESSFULTotal time: 3 seconds```This command will let you know that `console.war` was built and is in the correct place, under the `webapps` directory.```Susans-MacBook-Pro-247:quarks susancline$ find . -name console.war -print./target/java8/console/webapps/console.war```Now we know we have built `console.war`, so we're good to go.To run this sample from the command line:```Susans-MacBook-Pro-247:quarks susancline$ pwd/Users/susancline/git/quarksSusans-MacBook-Pro-247:quarks susancline$ java -cp target/java8/samples/lib/quarks.samples.console.jar:. quarks.samples.console.ConsoleWaterDetector```If everything is successful, you'll start seeing output.  You may have to scroll back up to get the URL of the console:```Susans-MacBook-Pro-247:quarks susancline$ java -cp target/java8/samples/lib/quarks.samples.console.jar:. quarks.samples.console.ConsoleWaterDetectorMar 07, 2016 12:04:52 PM org.eclipse.jetty.util.log.Log initializedINFO: Logging initialized @176msMar 07, 2016 12:04:53 PM org.eclipse.jetty.server.Server doStartINFO: jetty-9.3.6.v20151106Mar 07, 2016 12:04:53 PM org.eclipse.jetty.server.handler.ContextHandler doStartINFO: Started o.e.j.s.ServletContextHandler@614c5515{/jobs,null,AVAILABLE}Mar 07, 2016 12:04:53 PM org.eclipse.jetty.server.handler.ContextHandler doStartINFO: Started o.e.j.s.ServletContextHandler@77b52d12{/metrics,null,AVAILABLE}Mar 07, 2016 12:04:53 PM org.eclipse.jetty.webapp.StandardDescriptorProcessor visitServletINFO: NO JSP Support for /console, did not find org.eclipse.jetty.jsp.JettyJspServletMar 07, 2016 12:04:53 PM org.eclipse.jetty.server.handler.ContextHandler doStartINFO: Started o.e.j.w.WebAppContext@2d554825{/console,file:///private/var/folders/0c/pb4rznhj7sbc886t30w4vpxh0000gn/T/jetty-0.0.0.0-0-console.war-_console-any-3101338829524954950.dir/webapp/,AVAILABLE}{/console.war}Mar 07, 2016 12:04:53 PM org.eclipse.jetty.server.AbstractConnector doStartINFO: Started ServerConnector@66480dd7{HTTP/1.1,[http/1.1]}{0.0.0.0:57964}Mar 07, 2016 12:04:53 PM org.eclipse.jetty.server.Server doStartINFO: Started @426mshttp://localhost:57964/consoleWell1 alert, ecoli value is 1Well1 alert, temp value is 48Well3 alert, ecoli value is 1```Now point your browser to the URL displayed above in the output from running the Java command to launch the `ConsoleWaterDetector` application. In this case, the URL is `http://localhost:57964/console`.Below is a screen shot of what you should see if everything is working properly:# ConsoleWaterDetector application scenarioThe application is now running in your browser. Let's discuss the scenario for the application.A county agency is responsible for ensuring the safety of residents well water.  Each well they monitor has four different sensor types:* Temperature* Acidity* Ecoli* LeadThe sample application topology monitors 3 wells:* For the hypothetical scenario, Well1 and Well3 produce 'unhealthy' values from their sensors on occasion.  Well2 always produces 'healthy' values.  * Each well that is to be measured is added to the topology.  The topology polls each sensor (temp, ecoli, etc) for each well as a unit.  A TStream&lt;Integer&gt; is returned from polling the toplogy and represents a sensor reading.  Each sensor reading for the well has a tag added to it with the reading type i.e, \"temp\", and the well id.  Once all of the sensor readings are obtained and the tags added, each sensor reading is 'unioned' into a single TStream&lt;JsonObject&gt;.  Look at the `waterDetector` method for details on this.* Now, each well has a single stream with each of the sensors readings as a property with a name and value in the TStream&lt;JsonObject&gt;.  Next the `alertFilter` method is called on the TStream&lt;JsonObject&gt; representing each well.  This method checks the values for each well's sensors to determine if they are 'out of range' for healthy values. The `filter` oplet is used to do this. If any of the sensor's readings are out of the acceptable range the tuple is passed along. Those that are within an acceptable range are discarded.* Next the applications `splitAlert` method is called on each well's stream that contains the union of all the sensor readings that are out of range.  The `splitAlert` method uses the `split` oplet to split the incoming stream into 5 different streams.  Only those tuples that are out of range for each stream, which represents each sensor type, will be returned. The object returned from `splitAlert` is a list of TStream&lt;JsonObject&gt; objects. The `splitAlert` method is shown below:```public static List> splitAlert(TStream alertStream, int wellId) {        List> allStreams = alertStream.split(5, tuple -> {            if (tuple.get(\"temp\") != null) {                JsonObject tempObj = new JsonObject();                int temp = tuple.get(\"temp\").getAsInt();                if (temp = TEMP_ALERT_MAX) {                    tempObj.addProperty(\"temp\", temp);                    return 0;                } else {                    return -1;                }            } else if (tuple.get(\"acidity\") != null){                JsonObject acidObj = new JsonObject();                int acid = tuple.get(\"acidity\").getAsInt();                if (acid = ACIDITY_ALERT_MAX) {                    acidObj.addProperty(\"acidity\", acid);                    return 1;                } else {                    return -1;                }            } else if (tuple.get(\"ecoli\") != null) {                JsonObject ecoliObj = new JsonObject();                int ecoli = tuple.get(\"ecoli\").getAsInt();                if (ecoli >= ECOLI_ALERT) {                    ecoliObj.addProperty(\"ecoli\", ecoli);                    return 2;                } else {                    return -1;                }            } else if (tuple.get(\"lead\") != null) {                JsonObject leadObj = new JsonObject();                int lead = tuple.get(\"lead\").getAsInt();                if (lead >= LEAD_ALERT_MAX) {                    leadObj.addProperty(\"lead\", lead);                    return 3;                } else {                    return -1;                }            } else {                 return -1;            }        });        return allStreams;    }```* Next we want to get the temperature stream from the first well and put a rate meter on it to determine the rate at which the out of range values are flowing in the stream.```   List> individualAlerts1 = splitAlert(filteredReadings1, 1);   // Put a rate meter on well1's temperature sensor output   Metrics.rateMeter(individualAlerts1.get(0));```* Next all the sensors for well 1 have tags added to the stream indicating the stream is out of range for that sensor and the well id.  Next a sink is added, passing the tuple to a `Consumer` that formats a string to `System.out` containing the well Id, alert type (sensor type) and value of the sensor.  ```// Put a rate meter on well1's temperature sensor outputMetrics.rateMeter(individualAlerts1.get(0));individualAlerts1.get(0).tag(TEMP_ALERT_TAG, \"well1\").sink(tuple -> System.out.println(\"\\n\" + formatAlertOutput(tuple, \"1\", \"temp\")));individualAlerts1.get(1).tag(ACIDITY_ALERT_TAG, \"well1\").sink(tuple -> System.out.println(formatAlertOutput(tuple, \"1\", \"acidity\")));individualAlerts1.get(2).tag(ECOLI_ALERT_TAG, \"well1\").sink(tuple -> System.out.println(formatAlertOutput(tuple, \"1\", \"ecoli\")));individualAlerts1.get(3).tag(LEAD_ALERT_TAG, \"well1\").sink(tuple -> System.out.println(formatAlertOutput(tuple, \"1\", \"lead\")));```Output in the terminal window from the `formatAlertOutput` method will look like this:```Well1 alert, temp value is 86Well3 alert, ecoli value is 2Well1 alert, ecoli value is 1Well3 alert, acidity value is 1Well1 alert, lead value is 12Well1 alert, ecoli value is 2Well3 alert, lead value is 10Well3 alert, acidity value is 10```Notice how only those streams that are out of range for the temperature sensor type show output.## Detecting zero tuple countsAt the end of the `ConsoleWaterDetector` application is this snippet of code, added after the topology has been submitted:```dp.submit(wellTopology);while (true) {                MetricRegistry metricRegistry = dp.getServices().getService(MetricRegistry.class);                SortedMap counters = metricRegistry.getCounters();                Set> values = counters.entrySet();                for (Entry e : values) {                    if (e.getValue().getCount() == 0) {                        System.out.println(\"Counter Op:\" + e.getKey() + \" tuple count: \" + e.getValue().getCount());                    }                }                Thread.sleep(2000);        }```What this does is get all the counters in the `MetricRegistry` class and print out the name of the counter oplet they are monitoring along with the tuple count if it is zero.  Here is some sample output:```Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_44 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_45 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_46 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_47 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_89 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_95 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_96 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_97 has a tuple count of zero!Counter Op:TupleCounter.quarks.oplet.JOB_0.OP_98 has a tuple count of zero!```To summarize what the application is doing:- Unions all sensor type readings for a single well.- Filters all sensor type readings for a single well, passing on an object that only contains tuples for the object that have at least one sensor type with out of range values.- Splits the object that contained name/value pairs for sensor type and readings into individual sensor types returning only those streams that contain out of range values.- Outputs to the command line the well id, sensor type and value that is out of range.- Tags are added at various points in the topology for easier identification of either the well or some out of range condition.- The topology contains counters to measure tuple counts since `DevelopmentProvider` was used.- Individual rate meters were placed on well1 and well3's temperature sensors to determine the rate of 'unhealthy' values.- Prints out the name of the counter oplets whose tuple counts are zero.# Topology graph controlsNow that you have an understanding of what the application is doing, let's look at some of the controls in the console, so we can learn how to monitor the application.  Below is a screen shot of the top controls: the controls that affect the Topology Graph.* **Job**: A drop down to select which job is being displayed in the Topology Graph.  An application can contain multiple jobs.* **State**: Hovering over the 'State' icon shows information about the selected job.  The current and next states of the job, the job id and the job name.* **View by**: This select is used to change how the topology graph is displayed.  The three options for this select are:  - Static flow  - Tuple count  - Oplet kind  - Currently it is set to 'Static flow'. This means the oplets (represented as circles in the topology graph) do not change size, nor do the lines or links (representing the edges of the topology graph) change width or position.  The graph is not being refreshed when it is in 'Static flow' mode.* **Refresh interval**: Allows the user to select an interval between 3 - 20 seconds to refresh the tuple count values in the graph. Every X seconds the metrics for the topology graph are refreshed.  More about metrics a little bit later.* **Pause graph**: Stops the refresh interval timer.  Once the 'Pause graph' button is clicked, the user must push 'Resume graph' for the graph to be updated, and then refreshed at the interval set in the 'Refresh interval' timer.  It can be helpful to pause the graph if multiple oplets are occupying the same area on the graph, and their names become unreadable. Once the graph is paused, the user can drag an oplet off of another oplet to better view the name and see the edge(s) that connect them.* **Show tags**: If the checkbox appears in the top controls, it means:  - The 'View by' layer is capable of displaying stream tags.  - The topology currently shown in the topology graph has stream tags associated with it.* **Show all tags**: Selecting this checkbox shows all the tags present in the topology.  If you want to see only certain tags, uncheck this box and select the button labeled 'Select individual tags ...'.  A dialog will appear, and you can select one or all of the tags listed in the dialog which are present in the topology.The next aspect of the console we'll look at are the popups available when selecting 'View all oplet properties', hovering over an oplet and hovering over an edge (link).The screen shot below shows the output from clicking on the 'View all oplet properties' link directly below the job selector:Looking at the sixth line in the table, where the Name is 'OP_5', we can see that the Oplet kind is a Map, a (quarks.oplet.functional.Map), the Tuple count is 0 (this is because the view is in Static flow mode - the graph does not show the number of tuples flowing in it), the source oplet is 'OP_55', the target oplet is 'OP_60', and there are no stream tags coming from the source or target streams.  Relationships for all oplets can be viewed in this manner.Now, looking at the graph, if we want to see the relationships for a single oplet, we can hover over it. The image below shows the hover when we are over 'OP_5'.You can also hover over the edges of the topology graph to get information.  Hover over the edge (link) between 'OP_0' and 'OP_55'.  The image shows the name and kind of the oplet as the source, and the name and kind of oplet as the target.  Again the tuple count is 0 since this is the 'Static flow' view.  The last item of information in the tooltip is the tags on the stream.One or many tags can be added to a stream.  In this case we see the tags 'temperature' and 'well1'.The section of the code that adds the tags 'temperature' and 'well1' is in the `waterDetector` method of the `ConsoleWaterDetector` class.```public static TStream waterDetector(Topology topology, int wellId) {  Random rNum = new Random();  TStream temp = topology.poll(() -> rNum.nextInt(TEMP_RANDOM_HIGH - TEMP_RANDOM_LOW) + TEMP_RANDOM_LOW, 1, TimeUnit.SECONDS);  TStream acidity = topology.poll(() -> rNum.nextInt(ACIDITY_RANDOM_HIGH - ACIDITY_RANDOM_LOW) + ACIDITY_RANDOM_LOW, 1, TimeUnit.SECONDS);  TStream ecoli = topology.poll(() -> rNum.nextInt(ECOLI_RANDOM_HIGH - ECOLI_RANDOM_LOW) + ECOLI_RANDOM_LOW, 1, TimeUnit.SECONDS);  TStream lead = topology.poll(() -> rNum.nextInt(LEAD_RANDOM_HIGH - LEAD_RANDOM_LOW) + LEAD_RANDOM_LOW, 1, TimeUnit.SECONDS);  TStream id = topology.poll(() -> wellId, 1, TimeUnit.SECONDS);  // add tags to each sensor  temp.tag(\"temperature\", \"well\" + wellId);  ```# LegendThe legend(s) that appear in the console depend on the view currently displayed.  In the static flow mode, if no stream tags are present, there is no legend.  In this example we have stream tags in the topology, so the static flow mode gives us the option to select 'Show tags'.  If selected, the result is the addition of the Stream tags legend:This legend shows all the tags that have been added to the topology, regardless of whether or not 'Show all tags' is checked or specific tags have been selected from the dialog that appears when the 'Select individual tags ...' button is clicked.# Topology graphNow that we've covered most of the ways to modify the view of the topology graph and discussed the application, let's look at the topology graph as a way to understand our application.When analyzing what is happening in your application, here are some ways you might use the console to help you understand it:* Topology of the application - how the edges and vertices of the graph are related* Tuple flow  - tuple counts since the application was started* The affect of filters or maps on the downstream streams* Stream tags - if tags are added dynamically based on a condition, where the streams with tags are displayed in the topologyLet's start with the static flow view of the topology.  We can look at the graph, and we can also hover over any of the oplets or streams to better understand the connections.  Also, we can click 'View all oplet properties' and see the relationships in a tabular format.The other thing to notice in the static flow view are the tags.  Look for any colored edges (the links between the oplets).All of the left-most oplets have streams with tags.  Most of them have the color that corresponds to 'Multiple tags'.  If you hover over the edges, you can see the tags.  It's obvious that we have tagged each sensor with the sensor type and the well id.Now, if you look to the far right, you can see more tags on streams coming out of a `split` oplet.  They also have multiple tags, and hovering over them you can determine that they represent out of range values for each sensor type for the well.  Notice how the `split` oplet, OP_43, has no tags in the streams coming out of it.  If you follow that split oplet back, you can determine from the first tags that it is part of the well 2 stream.If you refer back to the `ConsoleWaterDetector` source, you can see that no tags were placed on the streams coming out of well2's split because they contained no out of range values.Let's switch the view to Oplet kind now.  It will make more clear which oplets are producing the streams with the tags on them.Below is an image of how the graph looks after switching to the Oplet kind view.In the Oplet kind view the links are all the same width, but the circles representing the oplets are sized according to tuple flow.  Notice how the circles representing OP_10, OP_32 and OP_21 are large in relation to OP_80, OP_88 and OP_89.  As a matter of fact, we can't even see the circle representing OP_89.  Looking at OP_35 and then the Oplet kind legend, you can see by the color that it is a Filter oplet.  This is because the filter that we used against well2, which is the stream that OP_35 is part of returned no tuples.  This is a bit difficult to see. Let's look at the Tuple count view.The Tuple count view will make it more clear that no tuples are following out of OP_35, which represents the filter for well2 and only returns out of range values.  You may recall that in this example well2 returned no out of range values.  Below is the screen shot of the graph in 'Tuple count' view mode.The topology graph oplets can sometimes sit on top of each other.  If this is the case, pause the refresh and use your mouse to pull down on the oplets that are in the same position. This will allow you to see their name.  Alternately, you can use the 'View all properties' table to see the relationships between oplets.# MetricsIf you scroll the browser window down, you can see a Metrics section.  This section appears when the application contains the following:* A ```DevelopmentProvider``` is used; this automatically inserts counters on the streams of the topology.* A ```quarks.metrics.Metric.Counter``` or ```quarks.metrics.Metric.RateMeter``` is added to an individual stream.## CountersIn the ```ConsoleWaterDetector``` application we used a ```DevelopmentProvider```.  Therefore, counters were added to most streams (edges) with the following exceptions (from the javadoc for ```quarks.metrics.Metric.Counter```):*Oplets are only inserted upstream from a FanOut oplet.**If a chain of Peek oplets exists between oplets A and B, a Metric oplet is inserted after the last Peek, right upstream from oplet B.**If a chain of Peek oplets is followed by a FanOut, a metric oplet is inserted between the last Peek and the FanOut oplet.The implementation is not idempotent; previously inserted metric oplets are treated as regular graph vertices. Calling the method twice will insert a new set of metric oplets into the graph.*Also, the application inserts counters on well2's streams after the streams from the individual sensors were unioned and then split:```    List> individualAlerts2 = splitAlert(filteredReadings2, 2);    TStream alert0Well2 = individualAlerts2.get(0);    alert0Well2  = Metrics.counter(alert0Well2);    alert0Well2.tag(\"well2\", \"temp\");    TStream alert1Well2 = individualAlerts2.get(1);    alert1Well2  = Metrics.counter(alert1Well2);    alert1Well2.tag(\"well2\", \"acidity\");    TStream alert2Well2 = individualAlerts2.get(2);    alert2Well2  = Metrics.counter(alert2Well2);    alert2Well2.tag(\"well2\", \"ecoli\");    TStream alert3Well2 = individualAlerts2.get(3);    alert3Well2  = Metrics.counter(alert3Well2);    alert3Well2.tag(\"well2\", \"lead\");```When looking at the select next to the label 'Metrics', make sure the 'Count, oplets OP_37, OP_49 ...' is selected.  This select compares all of the counters in the topology visualized as a bar graph.  An image is shown below:Hover over individual bars to get the value of the number of tuples flowing through that oplet since the application was started.  You can also see the oplet name.  You can see that some of the oplets have zero tuples flowing through them.The bars that are the tallest and therefore have the highest tuple count are OP_76, OP_67 and OP_65.  If you look back up to the topology graph, in the Tuple count view, you can see that the edges (streams) surrounding these oplets have the color that corresponds to the highest tuple count (in the pictures above that color is bright orange in the Tuple count legend).## RateMetersThe other type of metric we can look at are ```RateMeter``` metrics.  In the ```ConsoleWaterDetector``` application we added two rate meters here with the objective of comparing the rate of out of range readings between well1 and well3:```    List> individualAlerts1 = splitAlert(filteredReadings1, 1);    // Put a rate meter on well1's temperature sensor output    Metrics.rateMeter(individualAlerts1.get(0));    ...    List> individualAlerts3 = splitAlert(filteredReadings3, 3);    // Put a rate meter on well3's temperature sensor output    Metrics.rateMeter(individualAlerts3.get(0));```RateMeters contain the following metrics for each stream they are added to:  * Tuple count  * The rate of change in the tuple count. The following rates are available for a single stream:    * 1 minute rate change    * 5 minute rate change    * 15 minute rate change    * Mean rate changeNow change the Metrics select to the 'MeanRate'.  In our example these correspond to oplets OP_37 and OP_49:Hovering over the slightly larger bar, the one to the right, the name is OP_49.  Looking at the topology graph and changing the view to 'Static flow', follow the edges back from OP_49 until you can see an edge with a tag on it. You can see that OP_49's source is OP_51, whose source is OP_99.  The edge between OP_99 and it's source OP_48 has multiple tags.  Hovering over this stream, the tags are 'TEMP out of range' and 'well3'.If a single Rate Meter is placed on a stream, in addition to plotting a bar chart, a line chart over the last 20 measures can be viewed.  For example, if I comment out the addition of the rateMeter for well1 and then rerun the application, the Metrics section will look like the image below.  I selected the OneMinuteRate and 'Line chart' for Chart type:#SummaryThe intent of the information on this page is to help you understand the following:* How to add the console application to a Quarks application* How to run the `ConsoleWaterDetector` sample* The design/architecture in the `ConsoleWaterDetector` application* The controls for the Topology graph are and what they do, including the different views of the graph* The legend for the graph* How to interpret the graph and use the tooltips over the edges and vertices, as well as the 'View all properties' link* How to add counters and rate meters to a topology* How to use the metrics section to understand tuple counters and rate meters* How to correlate values from the metrics section with the topology graphThe Quarks console will continue to evolve and improve.  Please open an issue if you see a problem with the existing console, but more importantly add an issue if you have an idea of how to make the console better.  The more folks write Quarks applications and view them in the console, the more information we can gather from the community about what is needed in the console.  Please consider making a contribution if there is a feature in the console that would really help you and others!"

},




{
"title": "FAQ",
"tags": "",
"keywords": "",
"url": "../docs/faq",
"summary": "",
"body": "## What Is Quarks?Quarks provides APIs and a lightweight runtime to analyze streaming data at the edge.## What do you mean by the edge?The edge includes devices, gateways, equipment, vehicles, systems, appliances and sensors of all kinds as part of the Internet of Things.## How is Quarks used?Quarks can be used at the edge of the Internet of Things, for example, to analyze data on devices, engines, connected cars, etc.  Quarks could be on the device itself, or a gateway device collecting data from local devices.  You can write an edge application on Quarks and connect it to a Cloud service, such as the IBM Watson IoT Platform. It can also be used for enterprise data collection and analysis; for example log collectors, application data, and data center analytics.## How are applications developed?Applications are developed using a functional flow API to define operations on data streams that are executed as a graph of \"oplets\" in a lightweight embeddable runtime.  The SDK provides capabilities like windowing, aggregation and connectors with an extensible model for the community to expand its capabilities.## What APIs does Quarks support?Currently, Quarks supports APIs for Java and Android. Support for additional languages, such as Python, is likely as more developers get involved.  Please consider joining the Quarks open source development community to accelerate the contributions of additional APIs.## What type of analytics can be done with Quarks?Quarks provides windowing, aggregation and simple filtering. It uses Apache Common Math to provide simple analytics aimed at device sensors.  Quarks is also extensible, so you can call existing libraries from within your Quarks application.  In the future, Quarks will include more analytics, either exposing more functionality from Apache Common Math, other libraries or hand-coded analytics.## What connectors does Quarks support?Quarks supports connectors for MQTT, HTTP, JDBC, File, Apache Kafka and IBM Watson IoT Platform.  Quarks is extensible; you can add the connector of your choice.## What centralized streaming analytic systems does Quarks support?Quarks supports open source technology (such as Apache Spark, Apache Storm, Flink and samza), IBM Streams (on-premises or IBM Streaming Analytics on Bluemix), or any custom application of your choice.## Why do I need Quarks on the edge, rather than my streaming analytic system?Quarks is designed for the edge, rather than a more centralized system.  It has a small footprint, suitable for running on devices.  Quarks provides simple analytics, allowing a device to analyze data locally and to only send to the centralized system if there is a need, reducing communication costs.## Why do I need Quarks, rather than coding the complete application myself?Quarks is a tool for edge analytics that allows you to be more productive. Quarks provides a consistent data model (streams and windows) and provides useful functionality, such as aggregations, joins, etc. Using Quarks lets you to take advantage of this functionality, allowing you to focus on your application needs.## Where can I download Quarks to try it out?Quarks is migrating from github quarks-edge to Apache. You can download the source from Apache and build it yourself [here](https://github.com/apache/incubator-quarks).  You can also  find already built pre-Apache releases of Quarks for download [here](https://github.com/quarks-edge/quarks/releases/latest). These releases are not associated with Apache.## How do I get started?Getting started is simple. Once you have downloaded Quarks, everything you need to know to get up and running, you will find [here](quarks-getting-started). We suggest you also run the [Quarks sample programs](samples) to familiarize yourselves with the code base.## How can I get involved? We would love to have your help! Visit [Get Involved](community) to learn more about how to get involved.## How can I contribute code?Just submit a [pull request](https://github.com/apache/incubator-quarks) and wait for a committer to review.  For more information, visit our [committer page](committers) and read [DEVELOPMENT.md] (https://github.com/apache/incubator-quarks/blob/master/DEVELOPMENT.md) at the top of the code tree.## Can I become a committer?Read about Quarks committers and how to become a committer [here](committers).## Where can I get the code?The source code is available [here](https://github.com/apache/incubator-quarks).## Can I take a copy of the code and fork it for my own use?Yes. Quarks is available under the Apache 2.0 license which allows you to fork the code.  We hope you will contribute your changes back to the Quarks community.## How do I suggest new features?Click [Issues](https://issues.apache.org/jira/browse/QUARKS) to submit requests for new features. You may browse or query the Issues database to see what other members of the Quarks community have already requested.## How do I submit bug reports?Click [Issues](https://issues.apache.org/jira/browse/QUARKS) to submit a bug report.## How do I ask questions about Quarks?Use [site.data.project.user_list](mailto:{{ site.data.project.user_list }}) to submit questions to the Quarks community.## Why is Quarks Open Source?With the growth of the Internet of Things there is a need to execute analytics at the edge. Quarks was developed to address requirements for analytics at the edge for IoT use cases that were not addressed by central analytic solutions.  These capabilities will be useful to many organizations and that the diverse nature of edge devices and use cases is best addressed by an open community.  Our goal is to develop a vibrant community of developers and users to expand the capabilities and real-world use of Quarks by companies and individuals to enable edge analytics and further innovation for the IoT space."

},




{
"title": "Get Involved",
"tags": "",
"keywords": "",
"url": "../docs/getinvolved",
"summary": "",
"body": "# Get Involved with QuarksWelcome to the Quarks community!  We would love to have you participate as a user of Quarks, a contributor or both.## Contribute CodeIf you plan to make any significant contribution, you will need to have a Contributor License Agreement [(CLA)](https://github.com/quarks-edge/quarks/blob/master/licences/Quarks-cla-individual.pdf) on file.  Get a copy of the CLA, fill it out and follow the instructions in the CLA to file it.  Committers will require a CLA before they commit contributions.When you are considering a code contribution, make sure there is an [Issue](https://github.com/quarks-edge/quarks/issues) that describes your work or the bug you are fixing.  For significant contributions, please discuss your proposed changes in the Issue so that others can comment on your plans.  Someone else may be working on the same functionality, so it's good to communicate early and often.  A committer is more likely to accept your change if there is clear information in the Issue.  The best way to start on the code is to [fork](https://help.github.com/articles/fork-a-repo/) Quarks and make changes in your fork.  When you're happy with the changes in your fork, issue a [pull request](https://github.com/quarks-edge/quarks/pulls).  Make sure you document your code and contribute tests along with the code.We welcome new committers.  Get information on committers [here](committers).## Contribute Documentation for the Web SiteContributing documentation is similar to contributing code.  Follow the instructions in the Contribute Code Section above.  If you are submitting documentation for the web site, you will need to use Markdown and Jekyll to develop your web pages.* [Markdown Cheat Sheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)* [Using Jekyll with Pages](https://help.github.com/articles/using-jekyll-with-pages/)## Use Quarks and Participate in the CommunityPlease [download](https://github.com/quarks-edge/quarks/releases/latest) the latest release of Quarks and use it.  We would love to get your feedback.  Create an [Issue](https://github.com/quarks-edge/quarks/issues) for any bugs you encounter, requests for enhancements or questions you may have. Feel free to comment on existing issues as well.  You are welcome to update the [wiki](https://github.com/quarks-edge/quarks/wiki) with any information you want to provide to help others.  Just link in any new pages, to be sure they are not lost.  If you have any significant comments on existing wiki pages, open an Issue to have a discussion."

},




{
"title": "Introduction",
"tags": "getting_started",
"keywords": "",
"url": "../docs/home",
"summary": "",
"body": "## Quarks OverviewDevices and sensors are everywhere, and more are coming online every day. You need a way to analyze all of the data coming from your devices, but it can be expensive to transmit all of the data from a sensor to your central analytics engine.Quarks is an open source programming model and runtime for edge devices that enables you to analyze data and events at the device. When you analyze on the edge, you can:* Reduce the amount of data that you transmit to your analytics server* Reduce the amount of data that you storeA Quarks application uses analytics to determine when data needs to be sent to a back-end system for further analysis, action, or storage. For example, you can use Quarks to determine whether a system is running outside of normal parameters, such as an engine that is running too hot.If the system is running normally, you don’t need to send this data to your back-end system; it’s an added cost and an additional load on your system to process and store. However, if Quarks detects an issue, you can transmit that data to your back-end system to determine why the issue is occurring and how to resolve the issue.   Quarks enables you to shift from sending a continuous flow of trivial data to the server to sending only essential and meaningful data as it occurs. This is especially important when the cost of communication is high, such as when using a cellular network to transmit data, or when bandwidth is limited.The following use cases describe the primary situations in which you would use Quarks:* *Internet of Things (IoT):* Analyze data on distributed edge devices and mobile devices to:  * Reduce the cost of transmitting data  * Provide local feedback at the devices* *Embedded in an application server instance:* Analyze application server error logs in real time without impacting network traffic* *Server rooms and machine rooms:* Analyze machine health in real time without impacting network traffic or when bandwidth is limited### Deployment environmentsThe following environments have been tested for deployment on edge devices:* Java 8, including Raspberry Pi B and Pi2 B* Java 7* Android### Edge devices and back-end systemsYou can send data from a Quarks application to your back-end system when you need to perform analysis that cannot be performed on the edge device, such as:* Running a complex analytic algorithm that requires more resources, such as CPU or memory, than are available on the edge device.* Maintaining large amounts of state information about a device, such as several hours worth of state information for a patient’smedical device.* Correlating data from the device with data from other sources, such as:  * Weather data  * Social media data  * Data of record, such as a patient’s medical history or trucking manifests  * Data from other devicesQuarks communicates with your back-end systems through the following message hubs:* MQTT – The messaging standard for IoT* IBM Watson IoT Platform – A cloud-based service that provides a device model on top of MQTT* Apache Kafka – An enterprise-level message bus* Custom message hubsYour back-end systems can also use analytics to interact with and control edge devices. For example:* A traffic alert system can send an alert to vehicles that are heading towards an area where an accident occurred* A vehicle monitoring system can reduce the maximum engine revs to reduce the chance of failure before the next scheduled service if it detects patterns that indicate a potential problem"

},




{
"title": "Quarks",
"tags": "",
"keywords": "",
"url": "../",
"summary": "",
"body": ""

},




{
"title": "Overview",
"tags": "",
"keywords": "",
"url": "../docs/overview",
"summary": "",
"body": "# Quarks OverviewDevices and sensors are everywhere, and more are coming online every day. You need a way to analyze all of the data coming from your devices, but it can be expensive to transmit all of the data from a sensor to your central analytics engine.Quarks is an open source programming model and runtime for edge devices that enables you to analyze data and events at the device. When you analyze on the edge, you can:* Reduce the amount of data that you transmit to your analytics server* Reduce the amount of data that you storeA Quarks application uses analytics to determine when data needs to be sent to a back-end system for further analysis, action, or storage. For example, you can use Quarks to determine whether a system is running outside of normal parameters, such as an engine that is running too hot.If the system is running normally, you don’t need to send this data to your back-end system; it’s an added cost and an additional load on your system to process and store. However, if Quarks detects an issue, you can transmit that data to your back-end system to determine why the issue is occurring and how to resolve the issue.   Quarks enables you to shift from sending a continuous flow of trivial data to the server to sending only essential and meaningful data as it occurs. This is especially important when the cost of communication is high, such as when using a cellular network to transmit data, or when bandwidth is limited.The following use cases describe the primary situations in which you would use Quarks:* *Internet of Things (IoT):* Analyze data on distributed edge devices and mobile devices to:  * Reduce the cost of transmitting data  * Provide local feedback at the devices* *Embedded in an application server instance:* Analyze application server error logs in real time without impacting network traffic* *Server rooms and machine rooms:* Analyze machine health in real time without impacting network traffic or when bandwidth is limited## Deployment environmentsThe following environments have been tested for deployment on edge devices:* Java 8, including Raspberry Pi B and Pi2 B* Java 7* Android## Edge devices and back-end systemsYou can send data from a Quarks application to your back-end system when you need to perform analysis that cannot be performed on the edge device, such as:* Running a complex analytic algorithm that requires more resources, such as CPU or memory, than are available on the edge device.* Maintaining large amounts of state information about a device, such as several hours worth of state information for a patient’smedical device.* Correlating data from the device with data from other sources, such as:  * Weather data  * Social media data  * Data of record, such as a patient’s medical history or trucking manifests  * Data from other devicesQuarks communicates with your back-end systems through the following message hubs:* MQTT – The messaging standard for IoT* IBM Watson IoT Platform – A cloud-based service that provides a device model on top of MQTT* Apache Kafka – An enterprise-level message bus* Custom message hubsYour back-end systems can also use analytics to interact with and control edge devices. For example:* A traffic alert system can send an alert to vehicles that are heading towards an area where an accident occurred* A vehicle monitoring system can reduce the maximum engine revs to reduce the chance of failure before the next scheduled service if it detects patterns that indicate a potential problem"

},







{
"title": "Getting started with Quarks",
"tags": "",
"keywords": "",
"url": "../docs/quarks-getting-started",
"summary": "",
"body": "## What is Quarks?Quarks is an open source programming model and runtime for edge devices that enables you to analyze streaming data on your edge devices. When you analyze on the edge, you can:* Reduce the amount of data that you transmit to your analytics server* Reduce the amount of data that you storeFor more information, see the [Quarks overview](home)### Quarks and streaming analyticsThe fundamental building block of a Quarks application is a **stream**: a continuous sequence of tuples (messages, events, sensor readings, and so on).The Quarks API provides the ability to process or analyze each tuple as it appears on a stream, resulting in a derived stream.Source streams are streams that originate data for analysis, such as readings from a device's temperature sensor.Streams are terminated using sink functions that can perform local device control or send information to centralized analytic systems through a message hub.Quarks' primary API is functional where streams are sourced, transformed, analyzed or sinked though functions, typically represented as lambda expressions, such as `reading -> reading  80` to filter temperature readings in Fahrenheit.### Downloading QuarksTo access Quarks, download a release from GitHub. We recommend downloading the [latest release](https://github.com/quarks-edge/quarks/releases/latest).After you download and extract the Quarks package, you can set up your environment.### Setting up your environmentEnsure that you are running a supported environment. For more information, see the [Quarks overview](home). This guide assumes you're running Java 8.The Quarks Java 8 JAR files are located in the `quarks/java8/lib` directory.1. Create a new Java project in Eclipse, and specify Java 8 as the execution environment JRE:    2. Modify the Java build path to include all of the JAR files in the `quarks\\java8\\lib` directory:    Your environment is set up! You can start writing your first Quarks application.## Creating a simple applicationIf you're new to Quarks or to writing streaming applications, the best way to get started is to write a simple program.Quarks is a framework that pushes data analytics and machine learning to *edge devices*. (Edge devices include things like routers, gateways, machines, equipment, sensors, appliances, or vehicles that are connected to a network.) Quarks enables you to process data locally---such as, in a car engine, on an Android phone, or Raspberry Pi---before you send data over a network.For example, if your device takes temperature readings from a sensor 1,000 times per second, it is more efficient to process the data locally and send only interesting or unexpected results over the network. To simulate this, let's define a (simulated) TempSensor class:```java      import java.util.Random;      import quarks.function.Supplier;      /**     * Every time get() is called, TempSensor generates a temperature reading.     */    public class TempSensor implements Supplier {          double currentTemp = 65.0;          Random rand;          TempSensor(){              rand = new Random();          }          @Override          public Double get() {              // Change the current temperature some random amount              double newTemp = rand.nextGaussian() + currentTemp;              currentTemp = newTemp;              return currentTemp;          }      }```Every time you call `TempSensor.get()`, it returns a new temperature reading. The continuous temperature readings are a stream of data that a Quarks application can process.Our sample Quarks application processes this stream by filtering the data and printing the results. Let's define a TempSensorApplication class for the application:```java    import java.util.concurrent.TimeUnit;    import quarks.providers.direct.DirectProvider;    import quarks.topology.TStream;    import quarks.topology.Topology;    public class TempSensorApplication {        public static void main(String[] args) throws Exception {            TempSensor sensor = new TempSensor();            DirectProvider dp = new DirectProvider();                  Topology topology = dp.newTopology();            TStream tempReadings = topology.poll(sensor, 1, TimeUnit.MILLISECONDS);            TStream filteredReadings = tempReadings.filter(reading -> reading  80);            filteredReadings.print();            dp.submit(topology);          }    }```To understand how the application processes the stream, let's review each line.### Specifying a ProviderYour first step when you write a Quarks application is to create a[`DirectProvider`](http://quarks-edge.github.io/quarks/docs/javadoc/index.html?quarks/providers/direct/DirectProvider.html) :```java    DirectProvider dp = new DirectProvider();```A **Provider** is an object that contains information on how and where your Quarks application will run. A **DirectProvider** is a type of Provider that runs your application directly within the current virtual machine when its `submit()` method is called.### Creating a topologyAdditionally a Provider is used to create a[`Topology`](http://quarks-edge.github.io/quarks/docs/javadoc/index.html?quarks/topology/Topology.html) instance :```java    Topology topology = dp.newTopology();```In Quarks, **Topology** is a container that describes the structure of your application:* Where the streams in the application come from* How the data in the stream is modifiedIn the TempSensor application above, we have exactly one data source: the `TempSensor` object. We define the source stream by calling `topology.poll()`, which takes both a Supplier function and a time parameter to indicate how frequently readings should be taken. In our case, we read from the sensor every millisecond:```java    TStream tempReadings = topology.poll(sensor, 1, TimeUnit.MILLISECONDS);```### Defining The TStream objectCalling `topology.poll()` to define a source stream creates a `TStream` instance, which represents the series of readings taken from the temperature sensor.A streaming application can run indefinitely, so the TStream might see an arbitrarily large number of readings pass through it. Because a TStream represents the flow of your data, it supports a number of operations which allow you to modify your data.## Filtering a TStreamIn our example, we want to filter the stream of temperature readings, and remove any \"uninteresting\" or expected readings---specifically readings which are above 50 degrees and below 80 degrees. To do this, we call the TStream's `filter` method and pass in a function that returns *true* if the data is interesting and *false* if the data is uninteresting:```java    TStream filteredReadings = tempReadings.filter(reading -> reading  80);```    As you can see, the function that is passed to `filter` operates on each tuple individually. Unlike data streaming frameworks like [Apache Spark](https://spark.apache.org/), which operate on a collection of data in batch mode, Quarks achieves low latency processing by manipulating each piece of data as soon as it becomes available. Filtering a TStream produces another TStream that contains only the filtered tuples; for example, the `filteredReadings` stream.### Printing to outputWhen our application detects interesting data (data outside of the expected parameters), we want to print results. You can do this by calling the `TStream.print()` method, which prints using  `.toString()` on each tuple that passes through the stream:```java    filteredReadings.print();```Unlike `TStream.filter()`, `TStream.print()` does not produce another TStream. This is because `TStream.print()` is a **sink**, which represents the terminus of a stream.In addition to `TStream.print()` there are other sink operations that send tuples to an MQTT server, JDBC connection, file, or Kafka cluster. Additionally, you can define your own sink by invoking `TStream.sink()` and passing in your own function.### Submitting your applicationNow that your application has been completely declared, the final step is to run your application.`DirectProvider` contains a `submit()` method, which runs your application directly within the current virtual machine:```java    dp.submit(topology);```After you run your program, you should see output containing only \"interesting\" data coming from your sensor:```    49.904032311772596    47.97837504039084    46.59272336309031    46.681544551652934    47.400819234155236    ...```As you can see, all temperatures are outside the 50-80 degree range. In terms of a real-world application, this would prevent a device from sending superfluous data over a network, thereby reducing communication costs.## Further examplesThis example demonstrates a small piece of Quarks' functionality. Quarks supports more complicated topologies, such as topologies that require merging and splitting data streams, or perform operations which aggregate the last *N* seconds of data (for example, calculating a moving average).For more complex examples, see:* [Quarks sample programs](samples)* [Common Quarks operations](common-quarks-operations)"

},




{
"title": "Apache Quarks Documentation",
"tags": "",
"keywords": "",
"url": "../docs/quarks_index",
"summary": "",
"body": "## New DocumentationApache Quarks is evolving, and so is the documentation. If the existing documentation hasn't answered your questions, you can request new or updated documentation by opening an issue.Click on \"New Documentation\" to open an issue:   New Documentation## Providing FeedbackTo provide feedback on our documentation:1.  Navigate to the documentation page for which you are providing feedback.1.  Click on the **Feedback** button in the top right corner.This will open an issue for the page that you are currently visiting.  ## Contributing Documentation If you have ideas on how we can better document or explain some of the concepts, we would love to have your contribution!  The quarks.documentation site uses Github's flavor of Markdown and Jekyll markdown for our documentation.Refer to this documentation on Github's flavor of Markdown:  [Writing on Github](https://help.github.com/categories/writing-on-github)Refer to this documentation to get started:  [Using Jekyll with Pages](https://help.github.com/articles/using-jekyll-with-pages/)  To contribute, clone this project locally, make your changes, and create a [pull request](https://github.com/quarks-edge/quarks/pulls).To learn more, visit [Get Involved](getinvolved)"

},




{
"title": "Quickstart IBM Watson IoT Platform Sample",
"tags": "",
"keywords": "",
"url": "../docs/quickstart",
"summary": "",
"body": "# Quarks to Quickstart Quickly!IoT devices running quarks applications typically connect to back-end analytic systems through a message hub.Message hubs are used to isolate the back-end system from having to handle connections from thousands to millions of devices.An example of such a message hub designed for the Internet of Things is[IBM Watson IoT Platform](https://internetofthings.ibmcloud.com/). This cloud service runs on IBM's Bluemix cloud platformand Quarks provides a [connector](http://quarks-edge.github.io/quarks/docs/javadoc/index.html?quarks/connectors/iotf/IotfDevice.html).You can test out the service without any registration by using its Quickstart service and the Quarks sample application:[quarks.samples.connectors.iotf.IotfQuickstart](http://quarks-edge.github.io/quarks/docs/javadoc/index.html?quarks/samples/connectors/iotf/IotfQuickstart.html).You can execute the class directly from Eclipse, or using the script: `quarks/java8/scripts/connectors/iotf/runiotfquickstart.sh`When run it produces output like this, with a URL as the third line.Pointing any browser on any machine to that URL takes you to a view of the data coming from the sample application.This view is executing in Bluemix, thus the device events from this sample are being sent over the public internetto the Quickstart Bluemix service.Here's an example view:## Quarks CodeThe full source is at:[IotfQuickstart.java](https://github.com/quarks-edge/quarks/blob/master/samples/connectors/src/main/java/quarks/samples/connectors/iotf/IotfQuickstart.java)The first step to is to create a `IotDevice` instance that represents the connection to IBM Watson IoT Platform Qucikstart service.```java        // Declare a connection to IoTF Quickstart service        String deviceId = \"qs\" + Long.toHexString(new Random().nextLong());        IotDevice device = IotfDevice.quickstart(topology, deviceId);```Now any stream can send device events to the Quickstart service by simply calling its `events()` method.Here we map a stream of random numbers into JSON as the payload for a device event is typically JSON.```java          TStream json = raw.map(v -> {            JsonObject j = new JsonObject();            j.addProperty(\"temp\", v[0]);            j.addProperty(\"humidity\", v[1]);            j.addProperty(\"objectTemp\", v[2]);            return j;        });```    Now we have a stream of simulated sensor reading events as JSON tuples (`json`) we send them as events with event identifer (type) `sensors`  using `device`.  ```java      device.events(json, \"sensors\", QoS.FIRE_AND_FORGET);```It's that simple to send a Quarks stream to IBM Watson IoT Platform as device events."

},




{
"title": "Recipe 1. Hello Quarks!",
"tags": "",
"keywords": "",
"url": "../recipes/recipe_hello_quarks",
"summary": "",
"body": "Quarks' pure Java implementation is a powerful feature which allows it to be run on the majority of JVM-compatible systems. It also has the added benefit of enabling the developer to develop applications entirely within the Eclipse and Intellij ecosystems. For the purposes of this recipe, it will be assumed that the developer is using Eclipse. To begin the Hello World recipe, create a new project and import the necessary libraries as outlined in the [getting started guide](quarks-getting-started). Next, write the following template application:``` java    public static void main(String[] args) {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();    }```The *DirectProvider* is an object which allows the user to submit and run the final application. It also creates the *Topology* object, which gives the developer the ability to define a stream of strings.## Using Topology.stringsThe primary abstraction in Quarks is the `TStream`. A *TStream* represents the flow of data in a Quarks application; for example, the periodic floating point readings from a temperature sensor. The data items which are sent through a `TStream` are Java objects -- in the \"Hello Quarks!\" example, we are sending a single java.lang.String. There are a number of ways to create a `TStream`, and `Topology.strings` is the simplest. The user specifies a number of strings which will be used as the stream's data items.``` java    public static void main(String[] args) {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();        TStream helloStream = top.strings(\"Hello Quarks!\");    }```The `helloStream` stream is created, and the \"Hello Quarks!\" string will be sent as its single data item.## Printing to Output`TStream.print` can be used to print the data items of a stream to standard output by invoking the `toString` method of each data item. In this case the data items are already strings, but in principle `TStream.print` can be called on any stream, regardless of the datatype carried by the stream.``` java    public static void main(String[] args) {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();        TStream helloStream = top.strings(\"Hello Quarks!\");        helloStream.print();    }```## Submitting the ApplicationThe only remaining step is to submit the application, which is performed by the `DirectProvider`. Submitting a Quarks application initializes the threads which execute the `Topology`, and begins processing its data sources.``` java    public static void main(String[] args) {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();        TStream helloStream = top.strings(\"Hello Quarks!\");        helloStream.print();        dp.submit(top);    }```After running the application, the output is \"Hello Quarks!\":```Hello Quarks!```"

},




{
"title": "Recipe 2. Writing a Source Function",
"tags": "",
"keywords": "",
"url": "../recipes/recipe_source_function",
"summary": "",
"body": "In the previous [Hello Quarks!](recipe_hello_quarks) example, we create a data source which only generates a single Java String and prints it to output. Yet Quarks sources support the ability generate any data type as a source, not just Java types such as Strings and Doubles. Moreover, because the user supplies the code which generates the data, the user has complete flexibility for *how* the data is generated. This recipe demonstrates how a user could write such a custom data source.## Custom Source: Reading the Lines of a Web Page{{site.data.alerts.note}} Quarks' API provides convenience methods for performing HTTP requests. For the sake of example we are writing a HTTP data source manually, but in principle there are easier methods. {{site.data.alerts.end}}One example of a custom data source could be retrieving the contents of a web page and printing each line to output. For example, the user could be querying the Yahoo Finance website for the most recent stock price data of Bank of America, Cabot Oil & Gas, and Freeport-McMoRan Inc:``` java    public static void main(String[] args) throws Exception {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();                final URL url = new URL(\"http://finance.yahoo.com/d/quotes.csv?s=BAC+COG+FCX&f=snabl\");    }```Given the correctly formatted URL to request the data, we can use the *Topology.source* method to generate each line of the page as a data item on the stream. `Topology.source` takes a Java Supplier that returns an Iterable. The supplier is invoked once, and the items returned from the Iterable are used as the stream's data items. For example, the following `queryWebsite` method returns a supplier which queries  a URL and returns an Iterable of its contents:``` java    private static Supplier > queryWebsite(URL url) throws Exception{        return () -> {            List lines = new LinkedList();            try {                InputStream is = url.openStream();                BufferedReader br = new BufferedReader(                        new InputStreamReader(is));                                for(String s = br.readLine(); s != null; s = br.readLine())                    lines.add(s);            } catch (Exception e) {                e.printStackTrace();            }            return lines;        };    }``` When invoking `Topology.source`, we can use `queryWebsite` to return the required supplier, passing in the URL.  ``` java     public static void main(String[] args) throws Exception {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();                final URL url = new URL(\"http://finance.yahoo.com/d/quotes.csv?s=BAC+COG+FCX&f=snabl\");                TStream linesOfWebsite = top.source(queryWebsite(url));    } ```  Source methods such as `Topology.source` and `Topology.strings` return a `TStream`. If we print the `linesOfWebsite` stream to standard output and run the application, we can see that it correctly generates the data and feeds it into the Quarks runtime:Output:```java\"BAC\",\"Bank of America Corporation Com\",13.150,13.140,\"12:00pm - 13.145\"\"COG\",\"Cabot Oil & Gas Corporation Com\",21.6800,21.6700,\"12:00pm - 21.6775\"\"FCX\",\"Freeport-McMoRan, Inc. Common S\",8.8200,8.8100,\"12:00pm - 8.8035\"```## Polling source: reading data periodicallyA much more common scenario for a developer is the periodic generation of data from a source operator -- a data source may need to be polled every 5 seconds, 3 hours, or any time frame. To this end, `Topology` exposes the `poll` method which can be used to call a function at the frequency of the user's choosing. For example, a user might want to query Yahoo Finance every two seconds to retrieve the most up to date ticker price for a stock:```java    public static void main(String[] args) throws Exception {        DirectProvider dp = new DirectProvider();        Topology top = dp.newTopology();                final URL url = new URL(\"http://finance.yahoo.com/d/quotes.csv?s=BAC+COG+FCX&f=snabl\");                TStream> source = top.poll(queryWebsite(url), 2, TimeUnit.SECONDS);        source.print();                dp.submit(top);    }```**Output:**It's important to note that calls to `DirectProvider.submit` are non-blocking; the main thread will exit, and the threads executing the topology will continue to run. (Also, to see changing stock prices, the above example needs to be run during open trading hours. Otherwise, it will simply return the same results every time the website is polled)."

},




{
"title": "Sample Programs",
"tags": "",
"keywords": "",
"url": "../docs/samples",
"summary": "",
"body": "# Sample Quarks programsThe [Getting Started](quarks-getting-started) guide includes a step-by-step walkthrough of a simple Quarks application.Quarks also includes a number of sample Java applications that demonstrate different ways that you can use and implement Quarks.If you are using a released version of Quarks, the samples are already compiled and ready to use. If you downloaded the source or the Git project, the samples are built when you build Quarks.## ResourcesThe samples are currently available only for Java 8 environments. To use the samples, you'll need the resources in the following subdirectories of the Quarks package.:* The `java8/samples` directory contains the Java code for the samples.* The `java8/scripts` directory contains the shell scripts that you need to run the samples.If you use any of the samples in your own applications, ensure that you include the related Quarks JAR files in your `classpath`.## Recommended samplesIn addition to the sample application in the [Getting Started](quarks-getting-started) guide, the following samples can help you start developing with Quarks:* **HelloWorld**  This simple program demonstrates the basic mechanics of declaring and executing a topology.* **PeriodicSource**  This simple program demonstrates how to periodically poll a source for data to create a source stream.* **SimpleFilterTransform**  This simple program demonstrates a simple analytics pipeline:  source -> filter -> transform -> sink* **SensorAnalytics**  This more complex program demonstrates multiple facets of a Quarks application, including:  * Configuration control  * Reading data from a device with multiple sensors  * Running common analytic algorithms  * Publishing results to MQTT server  * Receiving commands  * Logging results locally  * Conditional stream tracing* **IBM Watson IoT Platform**    Samples that demonstrate how to use IBM Watson IoT Platform as the IoT scale message hub between Quarks and back-end analytic systems:      * [Sample using the no-registration Quickstart service](quickstart)Additional samples are documented in the [Quarks Overview](http://quarks-edge.github.io/quarks/docs/javadoc/overview-summary.html#overview.description) section of the Javadoc."

},
















































null
]
